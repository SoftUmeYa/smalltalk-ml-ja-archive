GraphMorph subclass: #HistogramMorph	instanceVariableNames: 'form hist r aLine target '	classVariableNames: ''	poolDictionaries: ''	category: 'VS-Image'!!HistogramMorph commentStamp: 'kawa 8/24/2004 01:14' prior: 0!ヒストグラムをGraph表示する.ドロップされたSketchMorphの輝度・赤・緑・青のいづれかのヒストグラムを表示する。表示する種別(輝度・赤・緑・青)は赤ハロメニューで選ぶ。examples:| gm |gm := HistogramMorph new .gm color: Color paleGreen. "背景色"gm dataColor: Color black. "バーの色"gm extent: 256@256. "大きさ　高さ：データ最大値は高さに規格化される、幅：データ数以上に設定する"gm openInWorld.gm borderWidth: 0.!]lang[(7 5 4 1 7 11 33 1 8 1 12 74 3 30 4 23 37 38)5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0!!HistogramMorph methodsFor: 'initialization' stamp: 'kawa 8/23/2004 02:31'!initialize	super initialize.	form _ nil.	hist _ Array new: 256.	1		to: 256		do: [:i | hist at: i put: 0].	self data: hist.	r _ #rgb.	self extent: 256@256.	aLine _ EnvelopeLineMorph basicNew								vertices: (Array with: 0@255 with: 255@0)								borderWidth: 1								borderColor: Color blue.	aLine addHandles.	self addMorph: aLine.! !!HistogramMorph methodsFor: 'dropping/grabbing' stamp: 'kawa 8/24/2004 23:24'!acceptDroppingMorph: aMorph event: evt 	"clear hist"	| w h |	1		to: 256		do: [:i | hist at: i put: 0].	form _ aMorph form.	target _ aMorph.	w _ form width.	h _ form height.	0		to: w - 1		do: [:x | 0				to: h - 1				do: [:y | 					| t b | 					r = #rgb						ifTrue: [b _ (form colorAt: x @ y) luminance.							b _ (b * 255) rounded + 1.							t _ hist at: b.							hist at: b put: t + 1].					r = #red						ifTrue: [b _ (form colorAt: x @ y) red.							b _ (b * 255) rounded + 1.							t _ hist at: b.							hist at: b put: t + 1].					r = #green						ifTrue: [b _ (form colorAt: x @ y) green.							b _ (b * 255) rounded + 1.							t _ hist at: b.							hist at: b put: t + 1].					r = #blue						ifTrue: [b _ (form colorAt: x @ y) blue.							b _ (b * 255) rounded + 1.							t _ hist at: b.							hist at: b put: t + 1]]].	self data: hist.	aMorph rejectDropMorphEvent: evt! !!HistogramMorph methodsFor: 'dropping/grabbing' stamp: 'kawa 8/24/2004 00:30'!wantsDroppedMorph: aMorph event: evt 	^ (aMorph isMemberOf: SketchMorph) or: [ aMorph isMemberOf: ImageMorph].! !!HistogramMorph methodsFor: 'menu' stamp: 'kawa 8/24/2004 23:31'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	aCustomMenu add: 'select histogram' action: #selectHistogram.	aCustomMenu add: 'apply tone-curve to an image' action: #applyToForm.! !!HistogramMorph methodsFor: 'menu' stamp: 'kawa 8/29/2004 19:28'!selectHistogram	| aMenu item selectedItem |	aMenu _ CustomMenu new title: 'Histogram:'.	item _ OrderedCollection new.	item add: '輝度'.	item add: '赤'.	item add: '緑'.	item add: '青'.	item		do: [:cName | aMenu add: cName action: cName].	selectedItem _ aMenu startUp.	selectedItem = '輝度'		ifTrue: [r _ #rgb].	selectedItem = '赤'		ifTrue: [r _ #red].	selectedItem = '緑'		ifTrue: [r _ #green].	selectedItem = '青'		ifTrue: [r _ #blue].!]lang[(133 2 15 1 15 1 15 1 108 2 41 1 41 1 43 1 25)0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0! !!HistogramMorph methodsFor: 'edit points' stamp: 'kawa 8/22/2004 10:05'!acceptGraphPoint: p at: index 	"既存ハンドルの移動"	| y vertices |	"ヒストグラム座標"	y _ (p adhereTo: self bounds) y.	"ハンドルの左右端は上下のみ可動"	index = 1		ifTrue: [^ self left@y].	index = (aLine vertices size)		ifTrue: [^ self right@y].	"	上記以外は	(vertices at: index) x < (vertices at: (index + 1)) x		かつ	(vertices at: (index - 1)) x < (vertices at: index) x	の場合はpを返す.これ以外はp x が上記条件を満たすx座標に変更する.	"	vertices := aLine vertices.	(vertices at: index) x > (vertices at: (index + 1)) x		ifTrue: [^((vertices at: (index + 1)) x) @ y].	(vertices at: (index - 1)) x > (vertices at: index) x		ifTrue: [^((vertices at: (index - 1)) x) @ y].	^ p x@ y.!]lang[(33 9 20 8 38 15 103 5 58 2 57 4 1 3 1 5 4 9 1 7 252)0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0! !!HistogramMorph methodsFor: 'edit points' stamp: 'kawa 8/25/2004 21:31'!applyToForm	| value v w h |	form = nil		ifTrue: [^ self].	value _ Array new: 256.	"トーンカーブ値"	"PolygonMorphから値を取得してトーンカーブ値を得る"	aLine		lineSegmentsDo: [:p1 :p2 | 			| p11 p22 | 			"Transcript show: 'p1:'; show: p1;show:' p2:';show:p2;cr."			" 						nearestPointAlongLineFromは誤差のため採用中止.代替としてBresenham 			algorithm"			p11 _ p1 - (self left @ self top).			p22 _ p2 - (self left @ self top).			v _ self linePointsFrom: p11 to: p22.			p11 x + 1				to: p22 x + 1				do: [:x | "Transcript show: 'x=';show:x;show:' v=';show:(v at: (x +  					1));cr."					value at: x put: self height							- (v at: x) - 1]].	"トーンカーブ値取得完了"	"self halt."	w _ form width.	h _ form height.	0		to: w - 1		do: [:x | 0				to: h - 1				do: [:y | 					| b c nc putColor | 					c _ form colorAt: x @ y.					r = #rgb						ifTrue: [b _ c brightness.							b _ (b * 255) asInteger + 1.							b - 1 = 0								ifTrue: [nc _ c]								ifFalse: [nc _ c / (b - 1)												* (value at: b)].							putColor _ ImageColor										r: nc red										g: nc green										b: nc blue.							form								pixelValueAt: x @ y								put: (putColor pixelValueForDepth: form depth)]]].	target layoutChanged!]lang[(88 7 16 18 155 10 1 5 323 11 568)0,5,0,5,0,5,0,5,0,5,0! !!HistogramMorph methodsFor: 'edit points' stamp: 'kawa 8/23/2004 00:26'!deletePoint: ix 	"ハンドルの削除が可能ならtrue"	^ false.!]lang[(19 12 15)0,5,0! !!HistogramMorph methodsFor: 'edit points' stamp: 'kawa 8/23/2004 00:25'!insertPointAfter: ix	"ハンドルの追加が可能ならtrue"	^ true.!]lang[(23 12 15)0,5,0! !!HistogramMorph methodsFor: 'edit points' stamp: 'kawa 8/24/2004 23:34'!linePointsFrom: p1 to: p2	"Bresenham algorithm: line drawing"	| x y dist xerr yerr dx dy incx incy linePoints |	"Transcript show: p1; show: ' '; show: p2; cr."	linePoints := Array new: 256.	dx := p2 x - p1 x.	dy := p2 y - p1 y.	dx < 0		ifTrue: [incx := -1. dx := dx negated]		ifFalse: [incx := dx ~= 0 ifTrue: [1] ifFalse: [0]].	dy < 0		ifTrue: [incy := -1. dy := dy negated]		ifFalse: [incy := dy ~= 0 ifTrue: [1] ifFalse:[0]].	dist := (dx > dy) ifTrue: [dx] ifFalse: [dy].	x := p1 x.	y := p1 y.	xerr := dx.	yerr := dy."	Transcript show: 'dist:'; show: dist;cr.	Transcript show: 'incx:'; show: incx;cr.	Transcript show: 'incy:'; show: incy;cr.	Transcript show: 'xerr '; show: xerr;cr.	Transcript show: 'yerr '; show: yerr;cr."	0 to: dist - 1 do: [ :i |		"Transcript show: '+x '; show: x; show: ' y ';show: y;cr."		linePoints at: (x + 1) asInteger put: y asInteger.		xerr := xerr + dx.		yerr := yerr + dy.		xerr > dist			ifTrue: [xerr := xerr - dist. x := x +incx.].		yerr > dist 			ifTrue: [yerr := yerr - dist. y := y + incy]].	linePoints at: (p2 x + 1) put: p2 y.	"self halt."	^ linePoints.! !Color subclass: #ImageColor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VS-Image'!!ImageColor methodsFor: 'as yet unclassified' stamp: 'kawa 8/24/2004 23:16'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val _ LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val at: 4 put: 16rFF.  "opaque alpha"		^ val].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !Object subclass: #ImgColor	instanceVariableNames: 'red green blue alpha '	classVariableNames: 'BlueShift GreenShift IndexedColors RedShift '	poolDictionaries: ''	category: 'VS-Image'!!ImgColor methodsFor: 'as yet unclassified' stamp: 'kawa 8/24/2004 22:54'!alpha: a	alpha := a.! !!ImgColor methodsFor: 'as yet unclassified' stamp: 'kawa 8/26/2004 01:34'!closestPixelValue1	"Return the nearest approximation to this color for a monochrome Form."	self luminance > 128		ifTrue: [^ 0]  "white"		ifFalse: [^ 1].  "black"! !!ImgColor methodsFor: 'as yet unclassified' stamp: 'kawa 8/26/2004 01:32'!luminance	"[0..255]"	^(0.298912 * red) + (0.586611 * green) + (0.114478 * blue).! !!ImgColor methodsFor: 'as yet unclassified' stamp: 'kawa 8/24/2004 22:53'!r: r g: g b: b	red := r.	green := g.	blue := b.	alpha := 255.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ImgColor class	instanceVariableNames: ''!!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 23:04'!colorFromPixelValue: p depth: d 	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a 	table. For greater depths, the color components are extracted and 	converted into a color."	| r g b alpha |	d = 8		ifTrue: [^ IndexedColors at: (p bitAnd: 255)					+ 1].	d = 4		ifTrue: [^ IndexedColors at: (p bitAnd: 15)					+ 1].	d = 2		ifTrue: [^ IndexedColors at: (p bitAnd: 3)					+ 1].	d = 1		ifTrue: [^ IndexedColors at: (p bitAnd: 1)					+ 1].	d = 16 | (d = 15)		ifTrue: ["five bits per component"			r _ (p bitShift: -10)						bitAnd: 31.			g _ (p bitShift: -5)						bitAnd: 31.			b _ p bitAnd: 31.			^ ImgColor				r: r * 8				g: g * 8				b: b * 8].	d = 32		ifTrue: ["eight bits per component; 8 bits of alpha"			r _ (p bitShift: -16)						bitAnd: 255.			g _ (p bitShift: -8)						bitAnd: 255.			b _ p bitAnd: 255.			alpha _ p bitShift: -24.			alpha = 0				ifTrue: [^ ImgColor transparent].			alpha < 255				ifTrue: [^ (ImgColor						r: r						g: g						b: b)						alpha: alpha]				ifFalse: [^ ImgColor						r: r						g: g						b: b]].	d = 12		ifTrue: ["four bits per component"			r _ (p bitShift: -8)						bitAnd: 15.			g _ (p bitShift: -4)						bitAnd: 15.			b _ p bitAnd: 15.			^ ImgColor				r: r * 16				g: g * 16				b: b * 16].	d = 9		ifTrue: ["three bits per component"			r _ (p bitShift: -6)						bitAnd: 7.			g _ (p bitShift: -3)						bitAnd: 7.			b _ p bitAnd: 7.			^ ImgColor				r: r * 32				g: g * 32				b: b * 32].	self error: 'unknown pixel depth: ' , d printString! !!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 22:26'!initialize	"ImgColor initialize"	RedShift _ 20.	GreenShift _ 10.	BlueShift _ 0.	self initializeIndexedColors.! !!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 22:49'!initializeIndexedColors	"Build an array of colors corresponding to the fixed colormap used 	for display depths of 1, 2, 4, or 8 bits."	"Color initializeIndexedColors"	| a index grayVal |	a _ Array new: 256.	"1-bit colors (monochrome)"	a		at: 1		put: (ImgColor				r: 255				g: 255				b: 255).	"white or transparent"	a		at: 2		put: (ImgColor				r: 0				g: 0				b: 0).	"black"	"additional colors for 2-bit color"	a		at: 3		put: (ImgColor				r: 255				g: 255				b: 255).	"opaque white"	a		at: 4		put: (ImgColor				r: 128				g: 128				b: 128).	"1/2 gray"	"additional colors for 4-bit color"	a		at: 5		put: (ImgColor				r: 255				g: 0				b: 0).	"red"	a		at: 6		put: (ImgColor				r: 0				g: 255				b: 0).	"green"	a		at: 7		put: (ImgColor				r: 0				g: 0				b: 255).	"blue"	a		at: 8		put: (ImgColor				r: 0				g: 255				b: 255).	"cyan"	a		at: 9		put: (ImgColor				r: 255				g: 255				b: 0).	"yellow"	a		at: 10		put: (ImgColor				r: 255				g: 0				b: 255).	"magenta"	a		at: 11		put: (ImgColor				r: 32				g: 32				b: 32).	"1/8 gray"	a		at: 12		put: (ImgColor				r: 64				g: 64				b: 64).	"2/8 gray"	a		at: 13		put: (ImgColor				r: 96				g: 96				b: 96).	"3/8 gray"	a		at: 14		put: (ImgColor				r: 160				g: 160				b: 160).	"5/8 gray"	a		at: 15		put: (ImgColor				r: 192				g: 192				b: 192).	"6/8 gray"	a		at: 16		put: (ImgColor				r: 224				g: 224				b: 224).	"7/8 gray"	"additional colors for 8-bit color"	"24 more shades of gray (1/32 increments but not repeating 1/8 	increments) "	index _ 17.	1		to: 31		do: [:v | v \\ 4 = 0				ifFalse: [grayVal _ v.					a						at: index						put: (ImgColor								r: grayVal								g: grayVal								b: grayVal).					index _ index + 1]].	"The remainder of color table defines a color cube with six steps 	for each primary color. Note that the corners of this cube repeat 	previous colors, but this simplifies the mapping between RGB colors 	and color map indices. This color cube spans indices 40 through 255 	(indices 41-256 in this 1-based array)."	0		to: 5		do: [:r | 0				to: 5				do: [:g | 0						to: 5						do: [:b | 							index _ 41 + (36 * r + (6 * b) + g).							index > 256								ifTrue: [self error: 'index out of range in color table compuation'].							a								at: index								put: (ImgColor										r: (r * 5)										g: (g * 5)										b: (b * 5))]]].	IndexedColors _ a! !!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 22:52'!r: r g: g b: b	^(self new) r: r g: g b: b.! !!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 22:56'!r: r g: g b: b alpha: a	^ (self r: r g: g b: b) alpha: a.! !!ImgColor class methodsFor: 'instance creation' stamp: 'kawa 8/24/2004 22:58'!transparent	^ self r: 0 g: 0 b: 0 alpha: 0.! !BMPReadWriter subclass: #WinIconReadWriter	instanceVariableNames: 'icoResourceType icoResourceCount iconWidth iconHeight iconColorCount iconFileSize iconDIBOffset '	classVariableNames: ''	poolDictionaries: ''	category: 'VS-Image'!!WinIconReadWriter methodsFor: 'accessing' stamp: 'kawa 8/21/2004 22:07'!readIconFileHeader	| reserved |	reserved := stream nextLittleEndianNumber: 2.	icoResourceType _ stream nextLittleEndianNumber: 2.	icoResourceCount _ stream nextLittleEndianNumber: 2! !!WinIconReadWriter methodsFor: 'accessing' stamp: 'kawa 8/21/2004 22:06'!readIconInfoHeader	| reserved |	iconWidth := stream nextLittleEndianNumber: 1.	iconHeight := stream nextLittleEndianNumber: 1.	iconColorCount := stream nextLittleEndianNumber: 1.	reserved := stream nextLittleEndianNumber: 1.	reserved := stream nextLittleEndianNumber: 2.	reserved := stream nextLittleEndianNumber: 2.	iconFileSize := stream nextLittleEndianNumber: 4.	iconDIBOffset := stream nextLittleEndianNumber: 4.! !!WinIconReadWriter methodsFor: 'accessing' stamp: 'kawa 8/20/2004 22:20'!understandsImageFormat	^ false! !ImgColor initialize!